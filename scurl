#!/usr/bin/env python2.7
# -*- encoding: utf-8 -*-

import re
import sys
import socket
from OpenSSL import SSL
from OpenSSL import crypto
from optparse import OptionParser
from urlparse import urlparse

# *. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .* *. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*

protocols = {'tlsv1.0': SSL.TLSv1_METHOD, 'tlsv1.1': SSL.TLSv1_1_METHOD, 'tlsv1.2': SSL.TLSv1_2_METHOD, 'sslv3' : SSL.SSLv3_METHOD}

errors = {
	'args': "SCURL ERROR: Missing arguments.",
	'netw': "SCURL ERROR: Could not connect to the request URL",
	'http': "SCURL ERROR: Please use an https scheme",
	'cert': "SCURL ERROR: SSL certificate problem: Invalid certificate chain"
}

CERTIFICATE_EXPIRED = 10
DEFAULT_PORT = 443
scurl_data = {}

def initOptionParser():
	parser.add_option("--tlsv1.0", action="store_const", const="tlsv1.0", dest="protocol", default="tlsv1.2", help="todo")
	parser.add_option("--tlsv1.1", action="store_const", const="tlsv1.1", dest="protocol", default="tlsv1.2", help="todo")
	parser.add_option("--tlsv1.2", action="store_const", const="tlsv1.2", dest="protocol", default="tlsv1.2", help="todo")
	parser.add_option("--sslv3", "-3", action="store_const", const="sslv3", dest="protocol", default="tlsv1.2", help="todo")

	# --crlfile <file>
	# (HTTPS/FTPS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that
	# are to be considered revoked. If this option is used several times, the last one will be used.
	parser.add_option("--crlfile", action="store", dest="crlfile")

	# --cacert <CA certificate>
	# (SSL) Tells curl to use the specified certificate file to verify the peer. The file may contain multiple CA certificates.
	# The certificate(s) must be in PEM format. Normally curl is built to use a default file for this, so this option is
	# typically used to alter that default file.
	parser.add_option("--cacert", action="store", dest="cacert")

	# --allow-state-certs <N>
	# Tells scurl to accept a certificate C as valid if (a) C is an otherwise valid certificate that has expired
	# and (b) C expired within the past N days. The argument N to this option must be a nonnegative integer.
	# If this option is used several times, the last one will be used.
	parser.add_option("--allow-state-certs", action="store", dest="expiration")

	# --ciphers <list of ciphers>
	# (SSL) Specifies which ciphers to use in the connection. The list of ciphers must specify valid ciphers.
	# Read up on SSL cipher list details on this URL: https://www.openssl.org/docs/apps/ciphers.html
	parser.add_option("--ciphers", action="store", dest="ciphers")

	# --pinnedpublickey (PPK) <file> (the path to a public key in PEM format)
	# If specified, scurl will only connect to a server if the servers TLS cert is exactly the one contained in the specified file.
	# Must use the SHA-256 cert fingerprint functionality built into pyOpenSSL to compare the servers cert to the PPK.
	# If the server sends the scurl client a certificate chain, you should only check that the leaf certificate matches
	# the pinned public key certificate - ignore any CA certificates that the server sends.
	# This option overrides the --cacert and --crlfile options. If this option is used several times, the last one will be used.
	parser.add_option("--pinnedpublickey", action="store", dest="ppkfile")
	
	return

def request(host, path):
    # [???] Add a user agent
    # [???] Connection close header (this is good)
    #return '''GET %sHTTP/1.1 \r\nHost: %s\r\nUser-Agent: scurl/cs255\r\nAccept: */*''' % (path, host)
    return '''GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: scurl/cs255\r\nAccept: */*\r\nConnection: close\r\n\r\n''' % (path, host)


# [???] How do we get the current time, and how do we factor in the N days?
def checkStaleCerts(cert):
 	#if options.cacert is not None:
		#print "checking for stale certificates"
	#date time format
 	return False

def checkAltNames(cert):
 	found = False;
 	for i in range(0, cert.get_extension_count()):
 		extension = cert.get_extension(i)
 		if extension.get_short_name() == "subjectAltName":
 			alt_names = crypto.X509Extension._subjectAltNameString(extension)
 			alt_names_arr = alt_names.replace('DNS:', '').split(', ')
 			if url.hostname in alt_names_arr:
 				found = True
 	return found

def notRevoked(cert):
    serial_num = format(cert.get_serial_number(), 'X')
    serial_num_str = str(serial_num)
    for r in scurl_data["revoked"]:
    	if r.get_serial() == serial_num_str:
    		return False
    return True

def callback(conn, cert, errnum, depth, result):
	certsubject = crypto.X509Name(cert.get_subject())
	commonname = certsubject.commonName
	
	if (options.crlfile is not None):
		return notRevoked(cert)
			
	if errnum == CERTIFICATE_EXPIRED:
		#check <if expiration is not None:>
		#print cert.get_notAfter()
		return checkStaleCerts(cert)
	elif errnum != 0:
		return False
	else:
		return True

def validCertificate(connection):
	cert = connection.get_peer_certificate()
	common_name = cert.get_subject().commonName.decode()

	rxString = r'(?:^|\s)([^.]+\.)?' + common_name.replace('.', '\.')[3:] + '(?:$|\s)'
	regex = re.compile(rxString)
	match = regex.match(url.hostname)

	alt_match = checkAltNames(cert)
	return (match or alt_match)

# *. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .* *. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*. · ° ▪ ° · .*

parser = OptionParser()
initOptionParser()
(options, args) = parser.parse_args()

if len(args) < 1:
	sys.exit(errors['args'])

url = urlparse(args[0])

if url.scheme != 'https':
	sys.exit(errors['http'])

context = SSL.Context(protocols[options.protocol])	# This is overridden by --cacert

if options.cacert is not None:
	context.load_verify_locations(options.cacert)
else:	
	context.set_default_verify_paths()

if options.ciphers is not None:
	context.set_cipher_list(options.ciphers)

# [???] Disabling Old Versions of SSL/TLS? 
# context.set_options(SSL.OP_NO_SSLv2)

# [???] If no server certificate is sent, because an anonymous cipher is used, SSL_VERIFY_PEER is ignored.
context.set_verify(SSL.VERIFY_PEER, callback)

# [???] Do I need to do <<s.settimeout(5)>>? What about socket arguments, ie <<socket(socket.AF_INET, socket.SOCK_STREAM)>>?
# [???] What about try catch for socket connection (or for handshake), ie <<except SSL.WantReadError>>?

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)		# [???] double check to make sure this works
connection = SSL.Connection(context, s)						# [???] For TCP, is socket.SOCK_STREAM necessary?

# Unless a port is specified in the url, use the default https port (443)
port = url.port if (url.port is not None) else DEFAULT_PORT
try:
	connection.connect((url.hostname,port))
except socket.error:
	sys.exit(errors['netw'])

connection.set_connect_state()					
connection.set_tlsext_host_name(url.hostname)

# ./scurl --crlfile ./sanity/data/sr.pem https://revoked.grc.com/
# ./scurl --crlfile ./sanity/data/sr.pem https://badssl.com/
if options.crlfile is not None:
    try:
    	crl_buffer = open(options.crlfile, 'r').read()
    except IOError:
    	sys.exit(':(')

    crl_object = crypto.load_crl(crypto.FILETYPE_PEM, crl_buffer)
    revoked_objects = crl_object.get_revoked()
    scurl_data["revoked"] = revoked_objects

try:
	connection.do_handshake()
except SSL.Error:
	sys.exit(errors['netw'])

if not validCertificate(connection):
	sys.exit(errors['cert'])

try:
	connection.sendall(request(url.hostname, url.path))
except SSL.Error:
	sys.exit(errors['netw'])

# [???] Do I need to do <<s.settimeout(5)>>?
header = True;
while 1:
	try:
		block = connection.recv(1024).decode('utf-8')
		if ("\r\n\r\n" in block and header):
			str_arr = block.split("\r\n\r\n", 1)
			block = str_arr[1]
			header = False;
		sys.stdout.write(block)
		sys.stdout.flush()
	# except SSL.WantReadError
	except SSL.Error:
		break

connection.shutdown()
connection.close()

sys.exit(0)	# [???] Is this neccessary?

# ▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫
# MOST PRESSING ISSUES TO DISCUSS WITH THE TAs DURING OFFICE HOURS
# ▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫

# 1. Implement try-catch error handling
# 2. Implement pinned public key option override, check for none [https://curl.haxx.se/libcurl/c/CURLOPT_PINNEDPUBLICKEY.html]
#    FYI with PPK it should be fine even if there's some other error with the certificate? (wrong host, subdomain, etc) yes
# 3. # [?????] Check for issue of non-zero exit code (https://piazza.com/class/ij0804zduh61i7?cid=670) 
# 4. Implement allowing for stale certs
# 5. Check for revoked certs
# 6. Check for timeouts

# ▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫▫▪▪▫

